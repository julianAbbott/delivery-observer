{"diagram":"ClassDiagram","nodes":[{"methods":"generateSchedule(Collection<BikeCourier>):void\nadd(BikeCourier):void\ngetNext(): BikeCourier","name":"AbstractBikerSchedule","x":530,"y":160,"attributes":"aSchedule:Queue<BikeCourier>","id":0,"type":"ClassNode"},{"methods":"generateSchedule(Collection):void\nadd(Object):void\ngetNext():Object","name":"Scheduler","x":910,"y":160,"id":1,"type":"InterfaceNode"},{"methods":"","name":"BikeCourier","x":280,"y":110,"attributes":"name: String\npin: int","id":2,"type":"ClassNode"},{"name":"","x":50,"y":340,"id":3,"type":"NoteNode"},{"name":"scheduling algo is the same for all observers","x":1230,"y":290,"id":4,"type":"NoteNode"},{"methods":"","name":"","x":1210,"y":540,"attributes":"","id":5,"type":"ClassNode"},{"methods":"newBiker(): void","name":"panel","x":600,"y":570,"attributes":"aBiker","id":6,"type":"ClassNode"},{"methods":"newBiker():void","name":"panel","x":1010,"y":570,"attributes":"aBiker","id":7,"type":"ClassNode"},{"methods":"Model(BikerSchedule) \naddObserver(Observer): void\nsetBiker():void\nnotifyObserver(Biker): void","name":"Model","x":250,"y":390,"attributes":"aObservers: List<Observers>\naSchedule: BikerSchedule \naBiker: Biker","id":8,"type":"ClassNode"},{"methods":"newBiker(): void","name":"panel","x":800,"y":570,"attributes":"aBiker","id":9,"type":"ClassNode"},{"name":"have two operation schedule or abort","x":1110,"y":440,"id":10,"type":"NoteNode"},{"methods":"newBiker():Biker","name":"Observer","x":800,"y":430,"id":11,"type":"InterfaceNode"},{"methods":"","name":"Client","x":50,"y":420,"attributes":"","id":12,"type":"ClassNode"},{"name":"I want to be able to just invoke an \nalgorithm but not define it's logic so that any implementation of \nscheduler can be used\nHowever I do not want to break encapsulation \n","x":1280,"y":120,"id":13,"type":"NoteNode"}],"edges":[{"startLabel":"","middleLabel":"","start":8,"end":11,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"middleLabel":"","start":12,"directionality":"Unidirectional","end":8,"type":"DependencyEdge"},{"Generalization Type":"Implementation","start":6,"end":11,"type":"GeneralizationEdge"},{"Generalization Type":"Implementation","start":9,"end":11,"type":"GeneralizationEdge"},{"Generalization Type":"Implementation","start":7,"end":11,"type":"GeneralizationEdge"},{"startLabel":"","middleLabel":"","start":8,"end":2,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"Generalization Type":"Implementation","start":0,"end":1,"type":"GeneralizationEdge"},{"startLabel":"","middleLabel":"","start":8,"end":0,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"startLabel":"","middleLabel":"","start":0,"end":2,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"}],"version":"3.4"}
