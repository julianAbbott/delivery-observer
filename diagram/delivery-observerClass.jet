{"diagram":"ClassDiagram","nodes":[{"methods":"newBiker(): void","name":"panel\n","x":600,"y":570,"attributes":"aBiker","id":4,"type":"ClassNode"},{"methods":"","name":"Employee","x":340,"y":10,"attributes":"name: String\npin: Int","id":9,"type":"ClassNode"},{"methods":"","name":"Biker","x":190,"y":110,"attributes":"name: String\npin: int","id":10,"type":"ClassNode"},{"methods":"Schedule( <Collection<Employee>> pEmployeePool,  Scheduler pScheduler)","name":"Schedule","x":480,"y":140,"attributes":"aSchedule: Scheduler<Employee>","id":13,"type":"ClassNode"},{"name":"have two operation schedule or abort","x":1110,"y":440,"id":0,"type":"NoteNode"},{"methods":"newBiker(): void","name":"panel","x":800,"y":570,"attributes":"aBiker","id":12,"type":"ClassNode"},{"methods":"newBiker():Biker","name":"Observer","x":800,"y":430,"id":7,"type":"InterfaceNode"},{"methods":"","name":"","x":1210,"y":540,"attributes":"","id":1,"type":"ClassNode"},{"name":"","x":50,"y":340,"id":2,"type":"NoteNode"},{"methods":"Model(BikerSchedule) \naddObserver(Observer): void\nnotifyObserver(Biker): void","name":"Model","x":250,"y":390,"attributes":"aObservers: List<Observers>\naSchedule: BikerSchedule \naBiker: Biker","id":8,"type":"ClassNode"},{"methods":"BikerSchedule( <Collection<Biker>> pBikePool , Scheduler pScheduler )","name":"BikerSchedule","x":170,"y":250,"attributes":"aSchedule: Scheduler<Biker>","id":11,"type":"ClassNode"},{"name":"scheduling algo is the same for all observers","x":1220,"y":350,"id":3,"type":"NoteNode"},{"methods":"","name":"AlgorithmScheduler","x":1000,"y":20,"attributes":"","id":16,"type":"ClassNode"},{"name":"I want to be able to just invoke an \nalgorithm but not define it's logic so that any implementation of \nscheduler can be used\nHowever I do not want to break encapsulation \n","x":1280,"y":120,"id":14,"type":"NoteNode"},{"methods":"populateSchedule(Collection<E> ):\nadd(Object o): void\ngetNext(): Object o","name":"AbstractScheduler","x":960,"y":130,"attributes":"aSchedule Collection<E>","id":15,"type":"ClassNode"},{"methods":"","name":"Client","x":50,"y":420,"attributes":"","id":6,"type":"ClassNode"},{"methods":"newBiker():void","name":"panel","x":1010,"y":570,"attributes":"aBiker","id":5,"type":"ClassNode"}],"edges":[{"startLabel":"","middleLabel":"","start":8,"end":7,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"middleLabel":"","start":6,"directionality":"Unidirectional","end":8,"type":"DependencyEdge"},{"Generalization Type":"Implementation","start":4,"end":7,"type":"GeneralizationEdge"},{"Generalization Type":"Implementation","start":12,"end":7,"type":"GeneralizationEdge"},{"Generalization Type":"Implementation","start":5,"end":7,"type":"GeneralizationEdge"},{"Generalization Type":"Inheritance","start":9,"end":10,"type":"GeneralizationEdge"},{"startLabel":"","middleLabel":"","start":13,"end":9,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"Generalization Type":"Inheritance","start":13,"end":11,"type":"GeneralizationEdge"},{"startLabel":"","middleLabel":"","start":11,"end":10,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"startLabel":"","middleLabel":"","start":8,"end":11,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"startLabel":"","middleLabel":"","start":13,"end":15,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"startLabel":"","middleLabel":"","start":11,"end":15,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"Generalization Type":"Inheritance","start":15,"end":16,"type":"GeneralizationEdge"}],"version":"3.4"}
