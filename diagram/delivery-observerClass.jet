{"diagram":"ClassDiagram","nodes":[{"name":"","x":50,"y":340,"id":0,"type":"NoteNode"},{"methods":"newBiker():void","name":"panel","x":1010,"y":570,"attributes":"aBiker","id":1,"type":"ClassNode"},{"methods":"Model(BikerSchedule) \naddObserver(Observer): void\nnotifyObserver(Biker): void","name":"Model","x":250,"y":390,"attributes":"aObservers: List<Observers>\naSchedule: BikerSchedule \naBiker: Biker","id":10,"type":"ClassNode"},{"methods":"","name":"Client","x":50,"y":420,"attributes":"","id":2,"type":"ClassNode"},{"methods":"newBiker():Biker","name":"Observer","x":800,"y":430,"id":3,"type":"InterfaceNode"},{"methods":"generateSchedule(Collection<BikeCourier>):void\nadd(BikeCourier):void\ngetNext(): BikeCourier","name":"AbstractBikerSchedule","x":530,"y":160,"attributes":"aSchedule:Queue<BikeCourier>","id":11,"type":"ClassNode"},{"methods":"","name":"BikeCourier","x":280,"y":110,"attributes":"name: String\npin: int","id":12,"type":"ClassNode"},{"methods":"newBiker(): void","name":"panel\n","x":600,"y":570,"attributes":"aBiker","id":4,"type":"ClassNode"},{"name":"scheduling algo is the same for all observers","x":1230,"y":290,"id":9,"type":"NoteNode"},{"methods":"generateSchedule(Collection):void\nadd(Object):void\ngetNext():Object","name":"Scheduler","x":910,"y":160,"id":13,"type":"InterfaceNode"},{"methods":"newBiker(): void","name":"panel","x":800,"y":570,"attributes":"aBiker","id":5,"type":"ClassNode"},{"methods":"","name":"","x":1210,"y":540,"attributes":"","id":6,"type":"ClassNode"},{"name":"have two operation schedule or abort","x":1110,"y":440,"id":7,"type":"NoteNode"},{"name":"I want to be able to just invoke an \nalgorithm but not define it's logic so that any implementation of \nscheduler can be used\nHowever I do not want to break encapsulation \n","x":1280,"y":120,"id":8,"type":"NoteNode"}],"edges":[{"startLabel":"","middleLabel":"","start":10,"end":3,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"middleLabel":"","start":2,"directionality":"Unidirectional","end":10,"type":"DependencyEdge"},{"Generalization Type":"Implementation","start":4,"end":3,"type":"GeneralizationEdge"},{"Generalization Type":"Implementation","start":5,"end":3,"type":"GeneralizationEdge"},{"Generalization Type":"Implementation","start":1,"end":3,"type":"GeneralizationEdge"},{"startLabel":"","middleLabel":"","start":10,"end":12,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"Generalization Type":"Implementation","start":11,"end":13,"type":"GeneralizationEdge"},{"startLabel":"","middleLabel":"","start":10,"end":11,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"},{"startLabel":"","middleLabel":"","start":11,"end":12,"endLabel":"","type":"AggregationEdge","Aggregation Type":"Aggregation"}],"version":"3.4"}
